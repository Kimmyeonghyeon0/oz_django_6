tuple 자체는 immutable하지만 tuple안의 요소는 mutable 할 수 있다

##파일의 실행 권한
-파일을 ㅜ만들면 기본적으로 "실행 할 수 있는 권한"이 없는 상태에서 생성됨
-어떻게하면 파일을 "실행할 수 있게"만듬?
    -chmod +x <파일이름>



    ## mysql 실행 확인하기;
    - lsof -i :3306 에 어떤 프로세스가 실행되고 있는지 확인할 수 있음 ㅇㅅㅇ





## 디버깅
    -김 포프: 나는 디버깅을 못하는 사람중에서 개발을 잘하는 사람을 거의 본적이 없고,
    개발을 잘하는 사람중에 디버깅을 못하는 사람은 본적 없으예~!
    -ㅈ중단점: 프로그램을 멈출건데 이 라인을 실행하기 직전에  멈춰줘...



## Django Isolation (격리, 헬스에서는 고립)
- 쟝고는 테스트용 데이터베이스를 따로 만듭니다. (이 데이터베이스는 처음에 비어있습니다.)
- (트랜젝션을 안 배운 상태긴 하지만) 쟝고는 모든 테스트를 트랜젝션 안에서 수행합니다.
- 위 두가지에 의해서 테스트들이 "격리"된 상태에서 수행되게 됩니다.
- 테스트가 외부 데이터에 흔들리지(영향을 받지) 않게 됩니다.

    def test_temp(self):
        self.assertEqual(
            [1, 2, 3],
            [3, 2, 1]
        )
        #assertEqual 로 두 리스트 비교하면 순서도 본다 -> 결과 = 실패
        #순서를 무시ㅡ하고 검증하고 싶다면 ->set()
        '''
            LIST1 = [1, 2, 3],
            LIST2 = [3, 2, 1]

    def test_temp(self):
        self.assertEqual(
            set[LIST1],
            set[LIST2]
        )
        '''
        #순서가 보장되어 있지 않는 함수를 검증할때는 then 에서도 항상
        "순서가 상관 없이" 검중 해야합니다
        그렇지 않으면 테스트가 간헐적으로 실패하게 됩니다
        테스트가 간헐적 으로 실패하면 배포할 때마다 스트레스

        ##실제로 일어나는 쿼리를 조회하는 방법
        orm을 사용할 지라도 내부에서 어떤 sql이 실행되는지 알아야 함
        from django.test.utils import CaptureQueryiesContext
        CaptureQueryiesContext를 사용하면 실제 발생하면 sql쿼리를 전부 볼수있

        with self.assert..